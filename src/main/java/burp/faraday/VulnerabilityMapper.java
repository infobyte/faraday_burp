/*
 * Faraday Penetration Test IDE Extension for Burp
 * Copyright (C) 2019  Infobyte LLC (http://www.infobytesec.com/)
 * See the file 'LICENSE' for the license information
 */

package burp.faraday;

import burp.*;
import burp.IParameter;
import burp.faraday.models.vulnerability.Host;
import burp.faraday.models.vulnerability.Service;
import burp.faraday.models.vulnerability.Vulnerability;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.List;

/**
 * This class will abstract the methods used to map Burp issues and requests
 * info actual Faraday vulnerabilities that can be sent to the server.
 */
public class VulnerabilityMapper {

    private static IExtensionHelpers helpers;

    public static void setHelpers(IExtensionHelpers helpers) {
        VulnerabilityMapper.helpers = helpers;
    }

    /**
     * Creates a {@link Vulnerability} instance from an {@link IScanIssue} instance.
     *
     * @param issue The issue to map from.
     *
     * @return The vulnerability filled with the information contained in the issue.
     */
    public static Vulnerability fromIssue(IScanIssue issue) {
        final Host host = getHostFromIssue(issue);
        final Service service = getServiceFromIssue(issue);

        final Vulnerability vulnerability = getVulnerabilityFromIssue(issue);

        vulnerability.setHost(host);
        vulnerability.setService(service);

        return vulnerability;
    }

    /**
     * Creates a {@link Vulnerability} instance from an {@link IHttpRequestResponse} instance.
     *
     * @param message The request to map from.
     *
     * @return The vulnerability filled with the information contained in the request.
     */
    public static Vulnerability fromRequest(IHttpRequestResponse message) {
        final Host host = getHostFromMessage(message);
        final Service service = getServiceFromMessage(message);

        final Vulnerability vulnerability = getVulnerabilityFromMessage(message);

        vulnerability.setHost(host);
        vulnerability.setService(service);

        return vulnerability;
    }

    /**
     * Builds a {@link Host} instance using the information contained in an {@link IScanIssue}
     *
     * @param issue The issue to map from.
     *
     * @return The Host filled with the information contained in the issue.
     */
    private static Host getHostFromIssue(IScanIssue issue) {
        final Host host = new Host();

        final String hostname = issue.getUrl().getHost();

        setHostnameAndIP(host, hostname, issue.getHttpService());

        return host;
    }

    /**
     * Builds a {@link Host} instance using the information contained in an {@link IHttpRequestResponse}
     *
     * @param message The issue to map from.
     *
     * @return The Host filled with the information contained in the request.
     */
    private static Host getHostFromMessage(IHttpRequestResponse message) {
        final Host host = new Host();

        final String hostname = message.getHttpService().getHost();

        setHostnameAndIP(host, hostname, message.getHttpService());

        return host;
    }

    /**
     * Builds a {@link Service} instance using the information contained in an {@link IScanIssue}.
     *
     * @param issue The issue to map from
     *
     * @return A Service filled with the information contained in the issue
     */
    private static Service getServiceFromIssue(IScanIssue issue) {

        final Service service = new Service();

        service.setName(issue.getHttpService().getProtocol());
        service.setProtocol(issue.getUrl().getProtocol());
        service.setPorts(new int[]{issue.getUrl().getPort()});
        service.setStatus("open");

        return service;
    }

    /**
     * Builds a {@link Service} instance using the information contained in an {@link IHttpRequestResponse}.
     *
     * @param message The message to map from
     *
     * @return A Service filled with the information contained in the message
     */
    private static Service getServiceFromMessage(IHttpRequestResponse message) {

        final Service service = new Service();

        final IHttpService httpService = message.getHttpService();

        service.setName(httpService.getProtocol());
        service.setPorts(new int[]{httpService.getPort()});
        service.setStatus("open");

        return service;
    }

    /**
     * Builds a {@link Vulnerability} instance using the information contained in an {@link IScanIssue}
     *
     * @param issue The issue to map from.
     *
     * @return A Vulnerability filled with the information contained in the issue.
     */
    private static Vulnerability getVulnerabilityFromIssue(IScanIssue issue) {
        final Vulnerability vulnerability = new Vulnerability();

        vulnerability.setName(issue.getIssueName());
        vulnerability.setSeverity(parseSeverity(issue));
        vulnerability.setResolution(parseResolution(issue));
        vulnerability.setDescription(parseDescription(issue));
        vulnerability.setData(parseData(issue));
        vulnerability.setPath(issue.getUrl().getPath());
        vulnerability.setWebsite(issue.getUrl().toString());

        // Some issues may not have requests associated. If we could not find a request, leave the vuln type
        // as Vulnerability

        if (issue.getHttpMessages().length > 0) {
            // If at least a request could be found, change the type to VulnerabilityWeb and analyze the first one.
            vulnerability.setType("VulnerabilityWeb");

            IHttpRequestResponse message = issue.getHttpMessages()[0];

            IRequestInfo requestInfo = helpers.analyzeRequest(message);

            addMessageToVuln(vulnerability, message, requestInfo);
        }

        return vulnerability;
    }

    /**
     * Parses the serverity and converts from the Burp scale into the Faraday scale
     *
     * @param issue The issue to get the severity from.
     *
     * @return The parsed severity accepted by Faraday
     */
    private static String parseSeverity(IScanIssue issue) {
        if (issue.getSeverity().equals("False positive")) {
            return "unclassified";
        }

        if (issue.getSeverity().equals("Information")) {
            return "informational";
        }

        return issue.getSeverity().toLowerCase();
    }

    /**
     * Builds a description using the informacion contained in an {@link IScanIssue}
     *
     * @param issue The issue to get the information from.
     *
     * @return A string representing the description of a {@link Vulnerability}
     */
    private static String parseDescription(IScanIssue issue) {
        StringBuilder description = new StringBuilder();

        String background = issue.getIssueBackground();
        if (background != null && !background.isEmpty()) {
            description.append("Background\n");
            description.append(background);
        }

        return description.toString().replaceAll("<(/p|br/|/li|/ul|/ol)>", "\n").replaceAll("<li>", "* ").replaceAll("</?[^>]*>", "");
    }

     /**
     * Builds a data using the informacion contained in an {@link IScanIssue}
     *
     * @param issue The issue to get the information from.
     *
     * @return A string representing the data of a {@link Vulnerability}
     */
    private static String parseData(IScanIssue issue) {
        StringBuilder data = new StringBuilder();

        if (issue.getIssueDetail() != null && !issue.getIssueDetail().isEmpty()) {
            data.append("Detail\n");
            data.append(issue.getIssueDetail());
        }

        return data.toString().replaceAll("<(/p|br/|/li|/ul|/ol)>", "\n").replaceAll("<li>", "* ").replaceAll("</?[^>]*>", "");
    }

    /**
     * Parses the parameters and builds a string to represent them.
     *
     * @param parameterList A list of {@link IParameter} instances.
     *
     * @return A String representing the parameters of a {@link Vulnerability}
     * <p>
     */
    private static String parseParameters(final List<IParameter> parameterList) {
        final StringBuilder params = new StringBuilder();

        for (IParameter p : parameterList) {
            if (p.getType() == IParameter.PARAM_URL) {
                params.append(p.getName());
                params.append("=");
                params.append(p.getValue());
                params.append(",");
                }
            }
        return params.toString();
    }

    /**
     * Parses the issue resolution stripping the HTML. If none is found, return an empty resolution.
     *
     * @param issue The issue to parse the resolution from.
     *
     * @return The resolution of a {@link Vulnerability}
     */
    private static String parseResolution(IScanIssue issue) {
        final String remediation = issue.getRemediationBackground();

        if (remediation == null) {
            return "";
        }

        return remediation.replaceAll("<(/p|br/|/li)>", "\n").replaceAll("<li>", "* ").replaceAll("</?[^>]*>", "");
    }

    /**
     * Builds a {@link Vulnerability} instance using the information contained in an {@link IHttpRequestResponse}
     *
     * @param message The request to map from.
     *
     * @return A Vulnerability filled with the information contained in the request.
     */
    private static Vulnerability getVulnerabilityFromMessage(IHttpRequestResponse message) {
        final Vulnerability vulnerability = new Vulnerability();

        IRequestInfo requestInfo = helpers.analyzeRequest(message);
        String url_path = requestInfo.getUrl().getPath();
        vulnerability.setName("Analyzing: " + "(" + url_path.substring(0, Math.min(url_path.length(), 20)) + ")");
        vulnerability.setSeverity("informational");
        vulnerability.setDescription("This request was manually sent using the Faraday for Burp extension.");
        vulnerability.setPath(url_path);
        vulnerability.setWebsite(requestInfo.getUrl().toString());

        vulnerability.setType("VulnerabilityWeb");

        addMessageToVuln(vulnerability, message, requestInfo);

        return vulnerability;
    }

    /**
     * Adds a request to a vulnerability as information.
     * <p>
     * If the request contains a null byte, add the base64 encoded request or response to avoid encoding issues.
     *
     * @param vulnerability The vulnerability to add the request and the response to.
     * @param message       The {@link IHttpRequestResponse} instance containing the request and response.
     * @param requestInfo   A {@link IRequestInfo} instance containing extra info from the request to extract the qury
     *                      method and params.
     */
    private static void addMessageToVuln(final Vulnerability vulnerability, IHttpRequestResponse message, IRequestInfo requestInfo) {

        final String query = requestInfo.getUrl().getQuery() != null ? requestInfo.getUrl().getQuery() : "";

        final byte[] request = message.getRequest();
        final byte[] response = message.getResponse();

        if (containsNullByte(request)) {
            vulnerability.setRequest("Binary request encoded with Base64:\n\n" + helpers.base64Encode(request));
        } else {
            vulnerability.setRequest(new String(request));
        }
        if (response != null){
            if (containsNullByte(response)) {
                vulnerability.setResponse("Binary response encoded with Base64:\n\n" + helpers.base64Encode(response));
            } else {
                vulnerability.setResponse(new String(response));
            }
            vulnerability.setMethod(requestInfo.getMethod());
            vulnerability.setParams(parseParameters(requestInfo.getParameters()));
            vulnerability.setQuery(query);
        }else {
            vulnerability.setResponse("Response Missing");
        }
    }


    /**
     * Sets the hostname and ip address of a {@link Host} using an {@link IHttpService} instance.
     *
     * @param host     The host to add the IP and hostname
     * @param hostname The hostname to add to the host.
     * @param service  The {@link IHttpService} to extract the information from.
     */
    private static void setHostnameAndIP(final Host host, String hostname, IHttpService service) {
        host.setHostnames(new String[]{hostname});

        String ip = hostname;
        try {
            ip = InetAddress.getByName(service.getHost()).getHostAddress();
        } catch (UnknownHostException ignored) {

        }
        host.setIp(ip);
    }

    private static boolean containsNullByte(byte[] byteArray) {
        for (byte b : byteArray) {
            if (b == 0) {
                return true;
            }
        }

        return false;

    }

}
